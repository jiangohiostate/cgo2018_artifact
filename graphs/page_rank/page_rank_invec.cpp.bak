#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <sys/time.h>
#include <vector>
#include "immintrin.h"
#include <cassert>
using namespace std;

#define DUMP 0.85
#define MAX_NODES 1700000
#define MAX_EDGES 40000000

void print_vec(__m512 v) {
  for(int i=0;i<16;i++) {
    cout << *((float *)&v+i) << " ";
  }
  cout << endl;
}

void print_vec(__m512i v) {
  for(int i=0;i<16;i++) {
    cout << *((int *)&v+i) << " ";
  }
  cout << endl;
}



long overhead = 0;

inline __m512 invec_reduce(__mmask16 mconf, __m512i vny, __m512 vdy) {

  __mmask16 mconft = mconf;
  __m512 vnewdy = vdy;

  if(mconft != 0xFFFF) { 

    if(!(mconft & 0x2)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+1));
      __mmask16 mt = _mm512_cmpeq_epi32_mask(vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x4)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+2));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x8)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+3));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x10)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+4));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x20)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+5));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x40)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+6));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x80)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+7));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x100)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+8));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x200)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+9));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x400)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+10));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x800)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+11));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x1000)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+12));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x2000)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+13));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x4000)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+14));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
    if(!(mconft & 0x8000)) {
      overhead++;
      __m512i vt = _mm512_set1_epi32(*((int*)&vny+15));
      __mmask16 mt = _mm512_cmpeq_epi32_mask( vt, vny);
      vnewdy = _mm512_mask_mov_ps(vnewdy, mt & (~mt+1), _mm512_set1_ps(_mm512_mask_reduce_add_ps(mt, vnewdy)));
      mconft |= mt;
    }
  }
  return vnewdy;
}




int nnodes, nedges;


int main(int argc, char *argv[]) {

  ifstream fin(argv[1]);
  fin >>  nnodes >> nedges;

  int *n1 = (int *)_mm_malloc(sizeof(int)*nedges, 64);
  int *n2 = (int *)_mm_malloc(sizeof(int)*nedges, 64);
  float *nneibor = (float *)_mm_malloc(sizeof(float)*nnodes, 64);

  for(int i=0;i<nnodes;i++) {
    nneibor[i] = 0;
  }

  int t = 0;
  int w;
  while(fin >> n1[t] >> n2[t] >> w) {
    nneibor[n1[t]] += 1.0;
    t++;
  }
  assert(t==nedges);
  cout << "input complete." << endl;

  // tilling

#define TILESIZE 32768

  int dtiles = nnodes / TILESIZE;
  if(nnodes % TILESIZE)dtiles++;
  int ntiles = dtiles * dtiles;
  vector<vector<pair<int, int> > > tiles(ntiles);
  for(int i=0;i<nedges;i++) {
    int tx = n1[i] / TILESIZE;
    int ty = n2[i] / TILESIZE;
    tiles[tx*dtiles+ty].push_back(make_pair(n1[i], n2[i]));
  }

  t = 0;
  for(int i=0;i<ntiles;i++) {
		  for(auto& edge : tiles[i]) {
			  n1[t] = edge.first;
			  n2[t] = edge.second;
			  t++;
		  }
  }



  float *rank = (float *)_mm_malloc(sizeof(float)*nnodes, 64);
  float *sum = (float *)_mm_malloc(sizeof(float)*nnodes, 64);


  __m512i vzero = _mm512_set1_epi32(0);





  for(int i=0;i<nnodes;i++) {
	  rank[i] = 1.0;
	  sum[i] = 0.0;
  }

  long time = 0;

  long total_bits = 0;

  int step = 0;
  float last_rank;
  struct timeval tv1, tv2;
  struct timezone tz1, tz2;


  do {
	  step++;
	  last_rank = rank[100];

	  for(int i=0;i<nnodes;i++) {
		  sum[i] = 0.0;
	  }

	  gettimeofday(&tv1, &tz1);



	  for(int i=0;i<nedges/16*16;i+=16) {
		  __m512i vnx = _mm512_load_epi32(n1+i);
		  __m512i vny = _mm512_load_epi32(n2+i);


		  __m512 vrankx = _mm512_i32gather_ps(vnx, rank, 4);
		  __m512 vnnx = _mm512_i32gather_ps(vnx, nneibor, 4);
		  __m512 vsumy = _mm512_i32gather_ps(vny, sum, 4);
		  __m512 vadd = _mm512_div_ps(vrankx, vnnx);

		  __m512i vconf = _mm512_conflict_epi32(vny);
		  __mmask16 mconf = _mm512_cmpeq_epi32_mask(vconf, vzero);

		  vadd = invec_reduce(mconf, vny, vadd);

		  vsumy = _mm512_add_ps(vsumy, vadd);
		  _mm512_mask_i32scatter_ps(sum, mconf, vny, vsumy, 4);
      total_bits += 16;

	  }

	  for(int j=nedges/16*16;j<nedges;j++) {
		  int nx = n1[j];
		  int ny = n2[j];
		  sum[ny] += rank[nx] / nneibor[nx];
	  }

	  gettimeofday(&tv2, &tz2);

	  time += tv2.tv_usec - tv1.tv_usec + 1000000 * (tv2.tv_sec - tv1.tv_sec);

	  for(int i = 0; i < nnodes; i++)
	  {
		  rank[i] = (1 - DUMP) / nnodes + DUMP * sum[i]; 	
	  }

  } while(((rank[100] - last_rank) > 0.001*last_rank) || ((rank[100]-last_rank) < -1*0.001*last_rank));


  cout << "rank[100]: " << rank[100] << endl;
  cout << "total computing time: " << time / 1000000.0 << " sec" << endl;
  cout << "number of steps: " << step << endl;
  cout << "overhead: " << 16.0*overhead / total_bits << endl;

  return 0;
}
